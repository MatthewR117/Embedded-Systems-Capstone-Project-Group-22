#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>

const char *WIFI_SSID     = "OnePlus 13";  // Define Wi-Fi SSID
const char *WIFI_PASSWORD = "12345678";    // Define Wi-Fi Password

const char *FIREBASE_HOST = "https://drjohnson0x01-default-rtdb.firebaseio.com"; // Define Firebase base URL
const char *FIREBASE_AUTH_SUFFIX = "";                                           // Define Firebase auth suffix if needed

WiFiClientSecure g_client;                 // Define secure Wi-Fi client used by HTTP

const int UART2_RX_PIN = 16;               // Define pin used as ESP32 RX2 (connect to STM32 TX6)
const int UART2_TX_PIN = 17;               // Define pin used as ESP32 TX2 (connect to STM32 RX6)

// Define variables that control how often relay commands are read from Firebase
unsigned long g_lastRelayPollMs = 0;       // Stores last time relay command was polled
const unsigned long g_relayPollIntervalMs = 300; // Relay polling interval in ms (300ms as requested)
unsigned char g_relayCmdByte = 0;          // Stores last relay command byte sent to STM32

// Define buffer that stores 16 telemetry bytes from STM32 (header excluded)
unsigned char g_telemBuf[16];              // 4 x 32 bit values (voltage, current, watts, watthours)

// Define framing variables that track header and data bytes from STM32
static bool   g_inFrame    = false;        // Flag that says we are currently inside a STM32 frame
static int    g_frameIndex = 0;            // Index into g_telemBuf during frame reception

// Define timeout variables for dropping partial frames
static unsigned long g_lastTelemByteMs = 0; // Stores time when last telemetry byte arrived
const unsigned long  g_telemTimeoutMs  = 1000; // Timeout in ms before dropping partial frame (increased to 1 second)

void connectWiFi(void);                    // Function that connects to Wi-Fi
bool fbGetInt(const char *path, long *valueOut); // Function that reads integer value from Firebase
bool fbPatchTelemetry(unsigned long vWord,
                      unsigned long cWord,
                      unsigned long wWord,
                      unsigned long whWord);     // Function that uploads telemetry words to Firebase
void handleRelay(void);                   // Function that reads relay command from Firebase and sends to STM32
void handleTelemetry(void);               // Function that receives telemetry from STM32 and uploads to Firebase

void setup() {
  Serial.begin(115200);                   // Start serial monitor

  Serial2.begin(115200, SERIAL_8N1, UART2_RX_PIN, UART2_TX_PIN); // Start UART2 link to STM32

  connectWiFi();                          // Connect ESP32 to Wi-Fi network
  g_client.setInsecure();                 // Allow HTTPS without certificate
}

void loop() {
  handleRelay();                          // Periodically check relay command in Firebase
  handleTelemetry();                      // Read telemetry frames from STM32 and send to Firebase
}

/*************** Wi-Fi ***************/
void connectWiFi(void) {
  WiFi.mode(WIFI_STA);                    // Set Wi-Fi to station mode
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);   // Start Wi-Fi connection

  while (WiFi.status() != WL_CONNECTED) { // Wait until Wi-Fi connects
    delay(500);
  }
}

/*************** Firebase helpers ***************/
bool fbGetInt(const char *path, long *valueOut) {
  if (WiFi.status() != WL_CONNECTED) {    // If Wi-Fi is disconnected reconnect
    connectWiFi();
  }

  HTTPClient http;                        // Create HTTP client
  String url = String(FIREBASE_HOST) + String(path) + String(FIREBASE_AUTH_SUFFIX); // Build full URL

  http.begin(g_client, url);              // Start HTTPS request
  int code = http.GET();                  // Send GET request

  unsigned long startTime = millis();     // Start timing

  while (code != HTTP_CODE_OK && millis() - startTime < 5000) {  // Retry for 5 seconds
    delay(500);
    code = http.GET();                   // Retry the request
  }

  if (code != HTTP_CODE_OK) {             // If request still fails, return false
    http.end();
    return false;
  }

  String body = http.getString();         // Read the response body
  http.end();

  body.trim();                            // Remove whitespace
  if (body.length() == 0 || body == "null") { // If no value stored yet
    return false;
  }

  long v = body.toInt();                  // Convert string to integer
  *valueOut = v;                          // Store value in output pointer
  return true;
}

bool fbPatchTelemetry(unsigned long vWord,
                      unsigned long cWord,
                      unsigned long wWord,
                      unsigned long whWord) {
  if (WiFi.status() != WL_CONNECTED) {    // If Wi-Fi dropped reconnect
    connectWiFi();
  }

  HTTPClient http;                        // Create HTTP client
  String path = "/iot_data.json";         // Path that stores telemetry in Firebase
  String url  = String(FIREBASE_HOST) + path + String(FIREBASE_AUTH_SUFFIX); // Build full URL

  http.begin(g_client, url);              // Start HTTPS request
  http.addHeader("Content-Type", "application/json"); // Set content type for JSON

  // Build JSON payload using 32-bit words from STM32
  String payload = String("{\"voltage\":")   + String(vWord)  +
                   String(",\"current\":")   + String(cWord)  +
                   String(",\"watts\":")     + String(wWord)  +
                   String(",\"watthours\":") + String(whWord) +
                   String("}");

  int code = http.sendRequest("PATCH", payload); // Send PATCH request to update telemetry fields

  if (code <= 0) {                         // If request failed
    http.end();
    return false;
  }

  String resp = http.getString();          // Optional: Read response (not used)
  http.end();

  return (code >= 200 && code < 300);      // Return true on HTTP 2xx
}

/*************** Relay handling with retries ***************/
// This function will ensure the relay fetches every 300ms and tries fetching multiple times before polling.
void handleRelay(void) {
  unsigned long now = millis();           // Get current time in ms
  if (now - g_lastRelayPollMs < g_relayPollIntervalMs) { // If not yet time to poll relay value
    return;
  }
  g_lastRelayPollMs = now;                // Update last poll time

  long relaysValue = 0;                   // Stores integer read from Firebase
  bool relaySuccess = false;
  for (int i = 0; i < 3; i++) {           // Try 3 times to fetch the relay data
    relaySuccess = fbGetInt("/iot_data/relays.json", &relaysValue);
    if (relaySuccess) {
      break;                              // Break out of the loop if successful
    }
    delay(500);                           // Wait a bit before retrying
  }

  if (!relaySuccess) {                    // If all attempts fail, exit the function
    Serial.println("[RELAY] Failed to fetch relay value from Firebase.");
    return;
  }

  g_relayCmdByte = (unsigned char)(relaysValue & 0xFF); // Use lower 8 bits as command byte to STM32

  Serial.print("[RELAY] Firebase relays int = ");
  Serial.println(relaysValue);
  Serial.print("[RELAY] UART cmd byte = 0x");
  if (g_relayCmdByte < 0x10) Serial.print("0");
  Serial.println(g_relayCmdByte, HEX);

  Serial2.write(g_relayCmdByte);          // Send relay command byte to STM32 over UART2
}

/*************** Telemetry handling with header strip ***************/
// STM32 sends: 0xAA header + 16 data bytes (4 x 32-bit words)
// ESP32 waits for 0xAA, buffers 16 bytes, converts to 4 unsigned long values, then uploads to Firebase
void handleTelemetry(void) {
  unsigned long now = millis();           // Get current time in ms

  // If inside a frame and no bytes have arrived within timeout, drop partial frame
  if (g_inFrame && (now - g_lastTelemByteMs > g_telemTimeoutMs)) {
    g_inFrame    = false;                 // Reset frame flag
    g_frameIndex = 0;                     // Reset index
  }

  while (Serial2.available() > 0) {       // While there is data from STM32
    int b = Serial2.read();               // Read next byte
    if (b < 0) {
      break;
    }
    uint8_t ub = (uint8_t)b;              // Cast to unsigned byte
    g_lastTelemByteMs = now;              // Update time of last telemetry byte

    if (!g_inFrame) {                     // If not currently in a frame
      if (ub == 0xAA) {                   // Wait for header 0xAA
        g_inFrame    = true;              // Start new frame
        g_frameIndex = 0;                 // Reset index for data bytes
      }
      // Ignore any bytes that are not header
    } else {
      // Inside frame: store up to 16 data bytes
      g_telemBuf[g_frameIndex++] = ub;

      if (g_frameIndex >= 16) {           // Once 16 bytes received, we have full payload
        unsigned long vWord = ((unsigned long)g_telemBuf[0] << 24) |
                              ((unsigned long)g_telemBuf[1] << 16) |
                              ((unsigned long)g_telemBuf[2] << 8)  |
                              ((unsigned long)g_telemBuf[3]);

        unsigned long cWord = ((unsigned long)g_telemBuf[4] << 24) |
                              ((unsigned long)g_telemBuf[5] << 16) |
                              ((unsigned long)g_telemBuf[6] << 8)  |
                              ((unsigned long)g_telemBuf[7]);

        unsigned long wWord = ((unsigned long)g_telemBuf[8] << 24) |
                              ((unsigned long)g_telemBuf[9] << 16) |
                              ((unsigned long)g_telemBuf[10] << 8) |
                              ((unsigned long)g_telemBuf[11]);

        unsigned long whWord = ((unsigned long)g_telemBuf[12] << 24) |
                               ((unsigned long)g_telemBuf[13] << 16) |
                               ((unsigned long)g_telemBuf[14] << 8)  |
                               ((unsigned long)g_telemBuf[15]);

        fbPatchTelemetry(vWord, cWord, wWord, whWord); // Upload 4 words to Firebase

        g_inFrame    = false;             // Reset frame state for next packet
        g_frameIndex = 0;
      }
    }
  }
}
