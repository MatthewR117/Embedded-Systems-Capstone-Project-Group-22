#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
const char *WIFI_SSID = "OnePlus 13"; // Define Wi-Fi SSID
const char *WIFI_PASSWORD = "12345678"; // Define Wi-Fi Password
const char *FIREBASE_HOST = "https://drjohnson0x01-default-rtdb.firebaseio.com"; // Define Firebase base URL
const char *FIREBASE_AUTH_SUFFIX = ""; // Define Firebase auth suffix if needed
WiFiClientSecure g_client; // Define secure Wi-Fi client used by HTTP
const int UART2_RX_PIN = 16; // Define pin used as ESP32 RX2 (connect to STM32 TX6)
const int UART2_TX_PIN = 17; // Define pin used as ESP32 TX2 (connect to STM32 RX6)
// Define variables that control how often relay commands are read from Firebase
unsigned long g_lastRelayPollMs = 0; // Stores last time relay command was polled
const unsigned long g_relayPollIntervalMs = 300; // Relay polling interval in ms (300ms as requested)
unsigned char g_relayCmdByte = 0; // Stores last relay command byte sent to STM32
// WiFi reconnect (non-blocking)
unsigned long g_lastWiFiAttemptMs = 0;
const unsigned long g_wifiReconnectIntervalMs = 5000;  // Try every 5s if disconnected
const unsigned long g_wifiConnectTimeoutMs = 10000;    // Max 10s per attempt
// Define buffer that stores 16 telemetry bytes from STM32 (header excluded)
unsigned char g_telemBuf[16]; // 4 x 32 bit values (voltage, current, watts, watthours)
// Define framing variables that track header and data bytes from STM32
static bool g_inFrame = false; // Flag that says we are currently inside a STM32 frame
static int g_frameIndex = 0; // Index into g_telemBuf during frame reception
// Define timeout variables for dropping partial frames
static unsigned long g_lastTelemByteMs = 0; // Stores time when last telemetry byte arrived
const unsigned long g_telemTimeoutMs = 1000; // Timeout in ms before dropping partial frame (increased to 1 second)
bool connectWiFi(void); // Function that connects to Wi-Fi (now returns bool)
bool fbGetInt(const char *path, long *valueOut); // Function that reads integer value from Firebase
bool fbPatchTelemetry(unsigned long vWord,
                      unsigned long cWord,
                      unsigned long wWord,
                      unsigned long whWord); // Function that uploads telemetry words to Firebase
void handleRelay(void); // Function that reads relay command from Firebase and sends to STM32
void handleTelemetry(void); // Function that receives telemetry from STM32 and uploads to Firebase
void handleWiFi(void); // Non-blocking WiFi manager
void setup() {
  Serial.begin(115200); // Start serial monitor
  Serial2.begin(115200, SERIAL_8N1, UART2_RX_PIN, UART2_TX_PIN); // Start UART2 link to STM32
  WiFi.mode(WIFI_STA); // Set WiFi mode
  connectWiFi(); // Initial connect attempt
  g_client.setInsecure(); // Allow HTTPS without certificate
}
void loop() {
  handleWiFi(); // Manage WiFi non-blockingly
  handleRelay(); // Periodically check relay command in Firebase
  handleTelemetry(); // Read telemetry frames from STM32 and send to Firebase
}
/*************** Wi-Fi (non-blocking) ***************/
void handleWiFi(void) {
  unsigned long now = millis();
  if (WiFi.status() == WL_CONNECTED) {
    g_lastWiFiAttemptMs = now;  // Reset timer if connected
    return;
  }

  if (now - g_lastWiFiAttemptMs < g_wifiReconnectIntervalMs) {
    return;  // Not time yet
  }

  g_lastWiFiAttemptMs = now;
  if (connectWiFi()) {
    Serial.println("[WIFI] Reconnected successfully");
  } else {
    Serial.println("[WIFI] Connection attempt failed - will retry");
  }
}

bool connectWiFi(void) {
  WiFi.disconnect(true);  // Clean slate
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  unsigned long startMs = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - startMs < g_wifiConnectTimeoutMs)) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();

  return (WiFi.status() == WL_CONNECTED);
}
/*************** Firebase helpers ***************/
bool fbGetInt(const char *path, long *valueOut) {
  if (WiFi.status() != WL_CONNECTED) {  // Quick check before HTTP
    Serial.println("[FB] WiFi down - skipping GET");
    return false;
  }
  HTTPClient http; // Create HTTP client
  String url = String(FIREBASE_HOST) + String(path) + String(FIREBASE_AUTH_SUFFIX); // Build full URL
  http.begin(g_client, url); // Start HTTPS request
  http.setTimeout(3000);  // 3s timeout for slow WiFi
  int code = http.GET(); // Send GET request (single attempt)
  if (code != HTTP_CODE_OK) { // If request fails, return false
    http.end();
    return false;
  }
  String body = http.getString(); // Read the response body
  http.end();
  body.trim(); // Remove whitespace
  if (body.length() == 0 || body == "null") { // If no value stored yet
    return false;
  }
  long v = body.toInt(); // Convert string to integer
  *valueOut = v; // Store value in output pointer
  return true;
}
bool fbPatchTelemetry(unsigned long vWord,
                      unsigned long cWord,
                      unsigned long wWord,
                      unsigned long whWord) {
  if (WiFi.status() != WL_CONNECTED) {  // Quick check
    Serial.println("[FB] WiFi down - skipping PATCH");
    return false;
  }
  HTTPClient http; // Create HTTP client
  String path = "/iot_data.json"; // Path that stores telemetry in Firebase
  String url = String(FIREBASE_HOST) + path + String(FIREBASE_AUTH_SUFFIX); // Build full URL
  http.begin(g_client, url); // Start HTTPS request
  http.setTimeout(3000);  // 3s timeout
  http.addHeader("Content-Type", "application/json"); // Set content type for JSON
  // Build JSON payload using 32-bit words from STM32
  String payload = String("{\"voltage\":") + String(vWord) +
                   String(",\"current\":") + String(cWord) +
                   String(",\"watts\":") + String(wWord) +
                   String(",\"watthours\":") + String(whWord) +
                   String("}");
  int code = http.sendRequest("PATCH", payload); // Send PATCH request to update telemetry fields
  if (code <= 0) { // If request failed
    http.end();
    return false;
  }
  String resp = http.getString(); // Optional: Read response (not used)
  http.end();
  return (code >= 200 && code < 300); // Return true on HTTP 2xx
}
/*************** Relay handling with retries ***************/
// This function will ensure the relay fetches every 300ms and tries fetching multiple times before polling.
void handleRelay(void) {
  unsigned long now = millis(); // Get current time in ms
  Serial.println("[RELAY] handleRelay called");  // Debug: Confirm function entry
  if (now - g_lastRelayPollMs < g_relayPollIntervalMs) { // If not yet time to poll relay value
    return;
  }
  Serial.println("[RELAY] Time to poll");  // Debug: Confirm timing check passed
  g_lastRelayPollMs = now; // Update last poll time
  long relaysValue = 0; // Stores integer read from Firebase
  bool relaySuccess = fbGetInt("/iot_data/relays.json", &relaysValue);  // Single attempt (no retry loop to avoid delays)
  if (relaySuccess) {
    g_relayCmdByte = (unsigned char)(relaysValue & 0xFF); // Use lower 8 bits as command byte to STM32
    Serial.print("[RELAY] Success - Firebase relays int = ");
    Serial.println(relaysValue);
    Serial.print("[RELAY] UART cmd byte = 0x");
    if (g_relayCmdByte < 0x10) Serial.print("0");
    Serial.println(g_relayCmdByte, HEX);
    Serial2.write(g_relayCmdByte); // Send relay command byte to STM32 over UART2
  } else {
    Serial.println("[RELAY] Poll failed - skipping send");  // Debug: Confirm failure
  }
}
/*************** Telemetry handling with header strip ***************/
// STM32 sends: 0xAA header + 16 data bytes (4 x 32-bit words)
// ESP32 waits for 0xAA, buffers 16 bytes, converts to 4 unsigned long values, then uploads to Firebase
void handleTelemetry(void) {
  unsigned long now = millis(); // Get current time in ms
  // If inside a frame and no bytes have arrived within timeout, drop partial frame
  if (g_inFrame && (now - g_lastTelemByteMs > g_telemTimeoutMs)) {
    g_inFrame = false; // Reset frame flag
    g_frameIndex = 0; // Reset index
  }
  while (Serial2.available() > 0) { // While there is data from STM32
    int b = Serial2.read(); // Read next byte
    if (b < 0) {
      break;
    }
    uint8_t ub = (uint8_t)b; // Cast to unsigned byte
    g_lastTelemByteMs = now; // Update time of last telemetry byte
    if (!g_inFrame) { // If not currently in a frame
      if (ub == 0xAA) { // Wait for header 0xAA
        g_inFrame = true; // Start new frame
        g_frameIndex = 0; // Reset index for data bytes
      }
      // Ignore any bytes that are not header
    } else {
      // Inside frame: store up to 16 data bytes
      g_telemBuf[g_frameIndex++] = ub;
      if (g_frameIndex >= 16) { // Once 16 bytes received, we have full
